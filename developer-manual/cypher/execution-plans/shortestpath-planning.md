### 3.7.6. 최단 경로 계획
###### Cypher에서 최단 경로 찾기 및 계획 방법.

Cypher에서 최단 경로를 계획하면 평가해야 하는 조건부에 따라 다른 쿼리 계획이 생길 수 있습니다. 내부적으로 Neo4j는 경로를 검색하는 동안 술어를 평가할 수 있는 경우 빠른 양방향 폭 우선 검색 알고리즘을 사용합니다. 따라서, 이 빠른 알고리즘은 경로에 보편적인 술어가 있을 때 항상 올바른 대답을 반환합니다. 예를 들어, 모든 노드가 ```Person``` 레이블을 갖는 최단 경로를 검색하거나 ```name``` 특성을 가진 노드가 없는 경우입니다.

조건자의 유효성 여부를 결정하기 전에 전체 경로를 검사해야하는 경우, 이 빠른 알고리즘을 사용하여 최단 경로를 찾을 수 없으므로 Neo4j는 느리면서 철저한 깊이 우선 탐색 알고리즘을 사용하여 찾을 필요가 있습니다 즉, 범용이 아닌 술어를 사용하는 최단 경로 쿼리에 대한 쿼리 계획에는 빠른 알고리즘이 성공하지 못하는 경우 경로를 찾기 위해 철저한 검색을 실행하는 것으로 대신하는 것이 포함됩니다. 예를 들어, 데이터에 따라 적어도 하나의 노드에 ```name='Charlie Sheen'```속성이 포함되어 있어야한다는 요구 사항과 같이 실존 조건자를 사용하는 최단 경로 쿼리에 대한 대답은 빠른 알고리즘에서 찾지 못할 수 있습니다. 이 경우 Neo4j는 철저한 검색을 사용하여 모든 경로를 열거하고 잠재적으로 대답을 반환합니다.

이 두 알고리즘의 실행 시간은 순서에 따라 다를 수 있으므로, 빠른 접근 방식이 시간이 민감한 쿼리에 사용되는지 확인하는 것이 중요합니다.

철저한 검색이 계획되면, 빠른 알고리즘이 일치하는 경로를 찾지 못한 경우에만 여전히 실행됩니다. 고속 알고리즘은 항상 계획 시간에 보장 될 수는 없지만 유효한 경로를 찾을 수 있기 때문에 항상 먼저 실행됩니다.

#### 3.7.6.1. 빠른 알고리즘을 이용한 최단 경로

**Query.**
```Javascript
MATCH (ms:Person { name: 'Martin Sheen' }),(cs:Person { name: 'Charlie Sheen' }), p = shortestPath((ms)-[rels:ACTED_IN*]-(cs))
WHERE ALL (r IN rels WHERE exists(r.role))
RETURN p
```
이 쿼리는 빠른 알고리즘으로 평가 될 수 있습니다. 평가되기전에 전체 경로를 볼 필요가 있는 술어가 없습니다.

**Query plan.**
```
+-------------------+----------------+------+---------+-------------------+---------------------------------------------+
| Operator          | Estimated Rows | Rows | DB Hits | Variables         | Other                                       |
+-------------------+----------------+------+---------+-------------------+---------------------------------------------+
| +ProduceResults   |              1 |    1 |       0 | p                 | p                                           |
| |                 +----------------+------+---------+-------------------+---------------------------------------------+
| +ShortestPath     |              1 |    1 |       9 | p, rels -- cs, ms | {p0 : all(r in rels where hasProp(r.role))} |
| |                 +----------------+------+---------+-------------------+---------------------------------------------+
| +CartesianProduct |              1 |    1 |       0 | ms -- cs          |                                             |
| |\                +----------------+------+---------+-------------------+---------------------------------------------+
| | +NodeIndexSeek  |              1 |    1 |       2 | cs                | :Person(name)                               |
| |                 +----------------+------+---------+-------------------+---------------------------------------------+
| +NodeIndexSeek    |              1 |    1 |       2 | ms                | :Person(name)                               |
+-------------------+----------------+------+---------+-------------------+---------------------------------------------+

Total database accesses: 13
```
#### 3.7.6.2. 경로에 대한 추가 조건부 검사가 있는 최단 경로

철저한 검색을 대체 시스템으로 사용하는 것을 고려하세요.

최단 경로 패턴에 적용되는 WHERE 절에 사용 된 술어는 가장 짧은 경로가 무엇인지 결정하기 전에 평가됩니다.

**Query.**
```Javascript
MATCH (cs:Person { name: 'Charlie Sheen' }),(ms:Person { name: 'Martin Sheen' }), p = shortestPath((cs)-[*]-(ms))
WHERE length(p)> 1
RETURN p
```
위의 쿼리와 달리, 쿼리는 전체 경로가 유효한지 여부를 알기전에 전체 경로가 조건을 따르는지 확인해야 하므로 쿼리 계획에 느리면서 철저한 검색 알고리즘에 대한 대체도 포함됩니다.

**Query plan.**
```
+--------------------------+----------------+------+---------+----------------------------------+--------------------------------------------+
| Operator                 | Estimated Rows | Rows | DB Hits | Variables                        | Other                                      |
+--------------------------+----------------+------+---------+----------------------------------+--------------------------------------------+
| +ProduceResults          |              0 |    1 |       0 | p                                | p                                          |
| |                        +----------------+------+---------+----------------------------------+--------------------------------------------+
| +AntiConditionalApply    |              0 |    1 |       0 | cs -- anon[95], anon[113], ms, p |                                            |
| |\                       +----------------+------+---------+----------------------------------+--------------------------------------------+
| | +Top1                  |              0 |    0 |       0 | anon[95], anon[113], ms, p       | anon[95]                                   |
| | |                      +----------------+------+---------+----------------------------------+--------------------------------------------+
| | +Projection            |              0 |    0 |       0 | anon[95] -- anon[113], ms, p     | { : length(p)}                             |
| | |                      +----------------+------+---------+----------------------------------+--------------------------------------------+
| | +Filter                |              0 |    0 |       0 | anon[113], ms, p                 | length(p) > {  AUTOINT2}                   |
| | |                      +----------------+------+---------+----------------------------------+--------------------------------------------+
| | +Projection            |              0 |    0 |       0 | p -- anon[113], ms               | {p : ProjectedPath(Set(, cs),<function2>)} |
| | |                      +----------------+------+---------+----------------------------------+--------------------------------------------+
| | +VarLengthExpand(Into) |              0 |    0 |       0 | anon[113], ms                    | (cs)-[:*]-(ms)                             |
| | |                      +----------------+------+---------+----------------------------------+--------------------------------------------+
| | +Argument              |              1 |    0 |       0 |                                  |                                            |
| |                        +----------------+------+---------+----------------------------------+--------------------------------------------+
| +Apply                   |              1 |    1 |       0 | cs, ms -- anon[113], p           |                                            |
| |\                       +----------------+------+---------+----------------------------------+--------------------------------------------+
| | +Optional              |              1 |    1 |       0 | anon[113], p                     |                                            |
| | |                      +----------------+------+---------+----------------------------------+--------------------------------------------+
| | +ShortestPath          |              0 |    1 |       1 | anon[113], p                     | {p0 : length(p) > {  AUTOINT2}}            |
| | |                      +----------------+------+---------+----------------------------------+--------------------------------------------+
| | +Argument              |              1 |    1 |       0 |                                  |                                            |
| |                        +----------------+------+---------+----------------------------------+--------------------------------------------+
| +CartesianProduct        |              1 |    1 |       0 | cs -- ms                         |                                            |
| |\                       +----------------+------+---------+----------------------------------+--------------------------------------------+
| | +NodeIndexSeek         |              1 |    1 |       2 | ms                               | :Person(name)                              |
| |                        +----------------+------+---------+----------------------------------+--------------------------------------------+
| +NodeIndexSeek           |              1 |    1 |       2 | cs                               | :Person(name)                              |
+--------------------------+----------------+------+---------+----------------------------------+--------------------------------------------+

Total database accesses: 5
```
보다 포괄적인 쿼리 계획의 작동 방식은 ```Apply``` / ```Optional```을 사용하여 빠른 알고리즘이 결과를 찾지 못하면 단순히 결과 스트림을 중지하는 대신 ```Null``` 결과가 생성되도록 합니다. 또한 플래너는 경로 변수가 경로 대신 ```null```을 가리키는 경우 철저한 검색을 실행하는 ```AntiConditionalApply```를 실행합니다.

철저한 검색이 대체 시스템으로 사용되는 것을 방지합니다.

**Query.**
```Javascript
MATCH (cs:Person { name: 'Charlie Sheen' }),(ms:Person { name: 'Martin Sheen' }), p = shortestPath((cs)-[*]-(ms))
WITH p
WHERE length(p)> 1
RETURN p
```

위의 쿼리와 마찬가지로, 이 쿼리는 유효여부를 알기 전에 전체 경로가 술어를 추적하는지 확인해야합니다. 그러나 WITH 절을 포함하면 쿼리 계획에 더 느린 철저한 검색 알고리즘이 포함되지 않습니다. 대신에 빠른 알고리즘에 의해 발견 된 경로가 이후에 필터링되어 응답이 반환되지 않을 수 있습니다.

**Query plan.**
```
+-------------------+----------------+------+---------+-----------------------------------+--------------------------------------+
| Operator          | Estimated Rows | Rows | DB Hits | Variables                         | Other                                |
+-------------------+----------------+------+---------+-----------------------------------+--------------------------------------+
| +ProduceResults   |              1 |    1 |       0 | p                                 | p                                    |
| |                 +----------------+------+---------+-----------------------------------+--------------------------------------+
| +Filter           |              1 |    1 |       0 | anon[146], anon[113], cs, ms, p   | anon[146]                            |
| |                 +----------------+------+---------+-----------------------------------+--------------------------------------+
| +Projection       |              1 |    1 |       0 | anon[146] -- anon[113], cs, ms, p | {p : p,  : length(p) > {  AUTOINT2}} |
| |                 +----------------+------+---------+-----------------------------------+--------------------------------------+
| +ShortestPath     |              1 |    1 |       1 | anon[113], p -- cs, ms            | {}                                   |
| |                 +----------------+------+---------+-----------------------------------+--------------------------------------+
| +CartesianProduct |              1 |    1 |       0 | cs -- ms                          |                                      |
| |\                +----------------+------+---------+-----------------------------------+--------------------------------------+
| | +NodeIndexSeek  |              1 |    1 |       2 | ms                                | :Person(name)                        |
| |                 +----------------+------+---------+-----------------------------------+--------------------------------------+
| +NodeIndexSeek    |              1 |    1 |       2 | cs                                | :Person(name)                        |
+-------------------+----------------+------+---------+-----------------------------------+--------------------------------------+

Total database accesses: 5
```
